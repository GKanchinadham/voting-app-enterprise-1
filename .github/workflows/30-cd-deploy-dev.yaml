# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                                                                                ║
# ║              ENTERPRISE CD PIPELINE - DEPLOY TO DEV                            ║
# ║                                                                                ║
# ║  Stage 3 of the CI/CD Pipeline:                                                ║
# ║  • Update Kustomize manifests                                                  ║
# ║  • Trigger ArgoCD sync                                                         ║
# ║  • Validate deployment health                                                  ║
# ║  • Run smoke tests                                                             ║
# ║  • Generate deployment report                                                  ║
# ║                                                                                ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

name: "🚀 CD: Deploy to DEV"

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true
        type: string
  workflow_call:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true
        type: string

env:
  AWS_REGION: us-west-2
  APP_NAME: voting-app
  ENVIRONMENT: dev
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  DEV_URL: https://opsera-voting-app-dev.agent.opsera.dev
  DEV_RESULTS_URL: https://results.opsera-voting-app-dev.agent.opsera.dev

permissions:
  contents: write
  id-token: write

jobs:
  # ════════════════════════════════════════════════════════════════════════════════
  # PRE-DEPLOYMENT VALIDATION
  # ════════════════════════════════════════════════════════════════════════════════
  pre-deploy-check:
    name: "🔎 Pre-Deploy Check"
    runs-on: ubuntu-latest
    outputs:
      ready: ${{ steps.check.outputs.ready }}
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify Image Exists
        id: check
        env:
          IMAGE_TAG: ${{ inputs.image_tag }}
        run: |
          echo "## 🔎 Pre-Deployment Validation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          
          READY=true
          
          for SERVICE in vote result worker; do
            if aws ecr describe-images --repository-name "$SERVICE" --image-ids imageTag="${IMAGE_TAG}" &>/dev/null; then
              echo "| \`${SERVICE}:${IMAGE_TAG}\` | ✅ Found |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| \`${SERVICE}:${IMAGE_TAG}\` | ❌ Not Found |" >> $GITHUB_STEP_SUMMARY
              READY=false
            fi
          done
          
          echo "ready=${READY}" >> $GITHUB_OUTPUT
          
          if [ "$READY" = "false" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "❌ **Pre-deployment check failed** - one or more images not found" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  # ════════════════════════════════════════════════════════════════════════════════
  # UPDATE MANIFESTS
  # ════════════════════════════════════════════════════════════════════════════════
  update-manifests:
    name: "📝 Update Manifests"
    runs-on: ubuntu-latest
    needs: [pre-deploy-check]
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update Kustomization
        env:
          IMAGE_TAG: ${{ inputs.image_tag }}
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          KUSTOMIZE_FILE=".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml"
          
          # Update image references
          sed -i "s|newName: .*/vote|newName: ${ECR_URI}/vote|" "$KUSTOMIZE_FILE"
          sed -i "s|newName: .*/result|newName: ${ECR_URI}/result|" "$KUSTOMIZE_FILE"
          sed -i "s|newName: .*/worker|newName: ${ECR_URI}/worker|" "$KUSTOMIZE_FILE"
          sed -i "s|newTag: .*|newTag: ${IMAGE_TAG}|g" "$KUSTOMIZE_FILE"
          
          echo "### 📝 Manifest Update" >> $GITHUB_STEP_SUMMARY
          echo "Updated \`${KUSTOMIZE_FILE}\` with tag \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY

      - name: Commit and Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin main || true
          git add .
          git diff --staged --quiet || git commit -m "chore(dev): deploy ${{ inputs.image_tag }} [skip ci]"
          git push origin main || echo "No changes to push"

  # ════════════════════════════════════════════════════════════════════════════════
  # ARGOCD SYNC
  # ════════════════════════════════════════════════════════════════════════════════
  argocd-sync:
    name: "🔄 ArgoCD Sync"
    runs-on: ubuntu-latest
    needs: [update-manifests]
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Cleanup Orphaned Resources
        run: |
          # Connect to spoke cluster to cleanup orphaned resources
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          
          NAMESPACE="voting-app-${{ env.ENVIRONMENT }}"
          
          echo "### 🧹 Orphaned Resource Cleanup" >> $GITHUB_STEP_SUMMARY
          
          # Delete old ReplicaSets with invalid/placeholder images (from previous failed deployments)
          echo "Checking for invalid ReplicaSets..."
          for rs in $(kubectl get rs -n "$NAMESPACE" -o name 2>/dev/null || true); do
            IMAGE=$(kubectl get "$rs" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || true)
            if echo "$IMAGE" | grep -qiE "PLACEHOLDER|invalid|none"; then
              echo "Deleting orphaned ReplicaSet with invalid image: $rs"
              kubectl delete "$rs" -n "$NAMESPACE" --force --grace-period=0 2>/dev/null || true
            fi
          done
          
          # Delete old StatefulSets if any (dev uses Deployments)
          for sts in db redis; do
            if kubectl get statefulset "$sts" -n "$NAMESPACE" &>/dev/null; then
              echo "Deleting old StatefulSet: $sts"
              kubectl delete statefulset "$sts" -n "$NAMESPACE" --force --grace-period=0 2>/dev/null || true
              echo "| Deleted StatefulSet | $sts |" >> $GITHUB_STEP_SUMMARY
            fi
          done
          
          echo "Orphaned resource cleanup complete" >> $GITHUB_STEP_SUMMARY

      - name: Sync ArgoCD Application
        run: |
          set -x  # Enable command tracing for debugging
          
          # Connect to hub cluster for ArgoCD operations
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          
          APP_NAME="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo ""
          echo "╔══════════════════════════════════════════════════════════════════════════════╗"
          echo "║                     ARGOCD SYNC - DEEP LOGGING ENABLED                       ║"
          echo "╚══════════════════════════════════════════════════════════════════════════════╝"
          echo "Timestamp: ${TIMESTAMP}"
          echo "Application: ${APP_NAME}"
          echo ""
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # STEP 1: PRE-SYNC STATE CAPTURE
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ STEP 1: PRE-SYNC STATE CAPTURE                                             │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          echo "[1.1] Current Application Status (FULL YAML):"
          echo "────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o yaml 2>&1 || echo "Application not found or error"
          echo ""
          
          echo "[1.2] Current Sync Status:"
          echo "────────────────────────────────────────────────"
          CURRENT_SYNC=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          CURRENT_HEALTH=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          CURRENT_REVISION=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.sync.revision}' 2>/dev/null || echo "Unknown")
          echo "  Sync Status: ${CURRENT_SYNC}"
          echo "  Health Status: ${CURRENT_HEALTH}"
          echo "  Current Revision: ${CURRENT_REVISION}"
          echo ""
          
          echo "[1.3] Current Operation State:"
          echo "────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | jq '.status.operationState // "No operation state"' || echo "Failed to get operation state"
          echo ""
          
          echo "[1.4] Current Conditions:"
          echo "────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | jq '.status.conditions // []' || echo "Failed to get conditions"
          echo ""
          
          echo "[1.5] Source Configuration:"
          echo "────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | jq '{repoURL: .spec.source.repoURL, path: .spec.source.path, targetRevision: .spec.source.targetRevision}' || echo "Failed to get source config"
          echo ""
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # STEP 2: CLEAR STUCK OPERATIONS
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ STEP 2: CLEAR STUCK OPERATIONS                                             │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          echo "[2.1] Attempting to clear operationState..."
          kubectl patch application "${APP_NAME}" -n argocd \
            --type merge -p '{"status":{"operationState":null}}' 2>&1 || echo "Note: Failed to clear operationState (may not exist)"
          echo ""
          
          echo "[2.2] Waiting 3 seconds..."
          sleep 3
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # STEP 3: HARD REFRESH
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ STEP 3: TRIGGER HARD REFRESH                                               │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          echo "[3.1] Setting refresh annotation to 'hard'..."
          kubectl patch application "${APP_NAME}" -n argocd \
            --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}' 2>&1 || echo "Failed to set hard refresh"
          echo ""
          
          echo "[3.2] Waiting 5 seconds for refresh to process..."
          sleep 5
          
          echo "[3.3] Post-refresh status:"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | jq '{sync: .status.sync.status, health: .status.health.status, reconciledAt: .status.reconciledAt}' || echo "Failed to get status"
          echo ""
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # STEP 4: TRIGGER SYNC
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ STEP 4: TRIGGER SYNC OPERATION                                             │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          SYNC_PAYLOAD='{"operation":{"initiatedBy":{"username":"github-actions","automated":false},"sync":{"prune":true,"syncStrategy":{"apply":{"force":true}}}}}'
          echo "[4.1] Sync Payload: ${SYNC_PAYLOAD}"
          echo ""
          
          echo "[4.2] Triggering sync..."
          kubectl patch application "${APP_NAME}" -n argocd \
            --type merge -p "${SYNC_PAYLOAD}" 2>&1 || echo "Failed to trigger sync"
          echo ""
          
          echo "[4.3] Waiting 3 seconds..."
          sleep 3
          
          echo "[4.4] Post-sync-trigger status:"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | jq '{
            sync: .status.sync.status,
            health: .status.health.status,
            operationPhase: .status.operationState.phase,
            operationMessage: .status.operationState.message
          }' || echo "Failed to get status"
          echo ""
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # STEP 5: MONITOR SYNC PROGRESS (10 iterations)
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ STEP 5: MONITOR SYNC PROGRESS                                              │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          for i in 1 2 3 4 5 6 7 8 9 10; do
            echo ""
            echo "[5.${i}] Sync Progress Check ($(date -u +"%H:%M:%S"))"
            echo "────────────────────────────────────────────────"
            
            SYNC_STATUS=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Error")
            HEALTH_STATUS=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Error")
            OP_PHASE=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "None")
            OP_MSG=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.operationState.message}' 2>/dev/null || echo "")
            
            echo "  Sync: ${SYNC_STATUS} | Health: ${HEALTH_STATUS} | Operation: ${OP_PHASE}"
            [ -n "$OP_MSG" ] && echo "  Message: ${OP_MSG}"
            
            # Get resource sync status
            echo "  Resources:"
            kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | \
              jq -r '.status.resources[]? | "    \(.kind)/\(.name): sync=\(.status) health=\(.health.status // "N/A")"' 2>/dev/null || true
            
            # Check if sync completed
            if [ "$OP_PHASE" = "Succeeded" ] || [ "$OP_PHASE" = "Failed" ] || [ "$OP_PHASE" = "Error" ]; then
              echo ""
              echo "  >>> Sync operation completed with phase: ${OP_PHASE}"
              break
            fi
            
            sleep 5
          done
          
          echo ""
          echo "### 🔄 ArgoCD Sync" >> $GITHUB_STEP_SUMMARY
          echo "Triggered sync for \`${APP_NAME}\`" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Final Sync Status | ${SYNC_STATUS} |" >> $GITHUB_STEP_SUMMARY
          echo "| Final Health Status | ${HEALTH_STATUS} |" >> $GITHUB_STEP_SUMMARY
          echo "| Operation Phase | ${OP_PHASE} |" >> $GITHUB_STEP_SUMMARY

  # ════════════════════════════════════════════════════════════════════════════════
  # VERIFY DEPLOYMENT
  # ════════════════════════════════════════════════════════════════════════════════
  verify-deployment:
    name: "✅ Verify Deployment"
    runs-on: ubuntu-latest
    needs: [argocd-sync]
    outputs:
      healthy: ${{ steps.verify.outputs.healthy }}
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Wait for Deployment
        id: verify
        run: |
          set -x  # Enable command tracing
          
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          
          APP_NAME="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          MAX_ATTEMPTS=30
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo ""
          echo "╔══════════════════════════════════════════════════════════════════════════════╗"
          echo "║                  DEPLOYMENT VERIFICATION - DEEP LOGGING                      ║"
          echo "╚══════════════════════════════════════════════════════════════════════════════╝"
          echo "Timestamp: ${TIMESTAMP}"
          echo "Application: ${APP_NAME}"
          echo "Namespace: ${NAMESPACE}"
          echo ""
          
          echo "### ✅ Deployment Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # SECTION A: FULL APPLICATION STATE DUMP
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ SECTION A: FULL APPLICATION STATE DUMP                                     │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          echo ""
          echo "[A.1] Complete Application YAML:"
          echo "═══════════════════════════════════════════════════════════════════════════════"
          kubectl get application "${APP_NAME}" -n argocd -o yaml 2>&1 || echo "Failed to get application"
          echo "═══════════════════════════════════════════════════════════════════════════════"
          echo ""
          
          echo "[A.2] Application Summary:"
          echo "────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | jq '{
            name: .metadata.name,
            namespace: .metadata.namespace,
            project: .spec.project,
            source: .spec.source,
            destination: .spec.destination,
            syncPolicy: .spec.syncPolicy,
            syncStatus: .status.sync.status,
            healthStatus: .status.health.status,
            reconciledAt: .status.reconciledAt,
            operationPhase: .status.operationState.phase,
            operationStartedAt: .status.operationState.startedAt,
            operationFinishedAt: .status.operationState.finishedAt,
            operationMessage: .status.operationState.message
          }' 2>/dev/null || echo "Failed to parse application"
          echo ""
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # SECTION B: OPERATION STATE DETAILS
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ SECTION B: OPERATION STATE DETAILS                                         │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          echo ""
          echo "[B.1] Full Operation State:"
          echo "────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | jq '.status.operationState // "No operation state"' || echo "Failed"
          echo ""
          
          echo "[B.2] Sync Result Resources (if any):"
          echo "────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | \
            jq -r '.status.operationState.syncResult.resources[]? | "  \(.kind)/\(.name): \(.status) - \(.message // "OK")"' 2>/dev/null || echo "  No sync result resources"
          echo ""
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # SECTION C: RESOURCE STATUS
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ SECTION C: RESOURCE STATUS                                                 │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          echo ""
          echo "[C.1] All Resources Table:"
          echo "────────────────────────────────────────────────"
          printf "%-30s %-25s %-12s %-12s %s\n" "KIND" "NAME" "SYNC" "HEALTH" "MESSAGE"
          echo "────────────────────────────────────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | \
            jq -r '.status.resources[]? | "\(.kind)|\(.name)|\(.status)|\(.health.status // "N/A")|\(.health.message // "")"' 2>/dev/null | \
            while IFS='|' read -r kind name status health message; do
              printf "%-30s %-25s %-12s %-12s %s\n" "$kind" "$name" "$status" "$health" "$message"
            done || echo "  No resources found"
          echo ""
          
          echo "[C.2] Resources with Issues (OutOfSync or Unhealthy):"
          echo "────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | \
            jq -r '.status.resources[]? | select(.status != "Synced" or .health.status != "Healthy") | "  ⚠️ \(.kind)/\(.name): sync=\(.status) health=\(.health.status // "N/A") - \(.health.message // "")"' 2>/dev/null || echo "  No issues found"
          echo ""
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # SECTION D: CONDITIONS
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ SECTION D: APPLICATION CONDITIONS                                          │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          echo ""
          echo "[D.1] All Conditions:"
          echo "────────────────────────────────────────────────"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | \
            jq -r '.status.conditions[]? | "  Type: \(.type)\n  Message: \(.message)\n  LastTransitionTime: \(.lastTransitionTime)\n  ────"' 2>/dev/null || echo "  No conditions"
          echo ""
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # SECTION E: KUBERNETES RESOURCE STATE (SPOKE CLUSTER)
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ SECTION E: KUBERNETES RESOURCE STATE (SPOKE CLUSTER)                       │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          
          # Switch to spoke cluster to check actual resources
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          
          echo ""
          echo "[E.1] Namespace Status:"
          echo "────────────────────────────────────────────────"
          kubectl get namespace "${NAMESPACE}" -o yaml 2>&1 || echo "  Namespace not found"
          echo ""
          
          echo "[E.2] All Pods:"
          echo "────────────────────────────────────────────────"
          kubectl get pods -n "${NAMESPACE}" -o wide 2>&1 || echo "  No pods found"
          echo ""
          
          echo "[E.3] Pod Details (with events):"
          echo "────────────────────────────────────────────────"
          for pod in $(kubectl get pods -n "${NAMESPACE}" -o name 2>/dev/null); do
            echo ""
            echo ">>> ${pod}:"
            kubectl describe "${pod}" -n "${NAMESPACE}" 2>&1 | tail -50 || true
            echo "────────────────────────────────────────────────"
          done
          echo ""
          
          echo "[E.4] Pod Logs (last 30 lines):"
          echo "────────────────────────────────────────────────"
          for pod in $(kubectl get pods -n "${NAMESPACE}" --no-headers -o custom-columns=":metadata.name" 2>/dev/null); do
            echo ""
            echo ">>> ${pod}:"
            kubectl logs "${pod}" -n "${NAMESPACE}" --tail=30 2>&1 || echo "  Failed to get logs"
            echo "────────────────────────────────────────────────"
          done
          echo ""
          
          echo "[E.5] Deployments:"
          echo "────────────────────────────────────────────────"
          kubectl get deployments -n "${NAMESPACE}" -o wide 2>&1 || echo "  No deployments found"
          echo ""
          
          echo "[E.6] Services:"
          echo "────────────────────────────────────────────────"
          kubectl get services -n "${NAMESPACE}" -o wide 2>&1 || echo "  No services found"
          echo ""
          
          echo "[E.7] Ingresses:"
          echo "────────────────────────────────────────────────"
          kubectl get ingress -n "${NAMESPACE}" -o wide 2>&1 || echo "  No ingresses found"
          echo ""
          
          echo "[E.8] Events (last 20):"
          echo "────────────────────────────────────────────────"
          kubectl get events -n "${NAMESPACE}" --sort-by='.lastTimestamp' 2>&1 | tail -20 || echo "  No events"
          echo ""
          
          # Switch back to hub cluster for ArgoCD monitoring
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # SECTION F: VERIFICATION LOOP
          # ═══════════════════════════════════════════════════════════════════════════════
          echo "┌─────────────────────────────────────────────────────────────────────────────┐"
          echo "│ SECTION F: VERIFICATION LOOP (${MAX_ATTEMPTS} attempts, 10s interval)      │"
          echo "└─────────────────────────────────────────────────────────────────────────────┘"
          echo ""
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
            SYNC=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            OP_PHASE=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "None")
            SYNC_ERROR=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.operationState.message}' 2>/dev/null || echo "")
            CONDITION=$(kubectl get application "${APP_NAME}" -n argocd -o jsonpath='{.status.conditions[0].message}' 2>/dev/null || echo "")
            
            echo "[F.${i}] $(date -u +"%H:%M:%S") | Sync: ${SYNC} | Health: ${HEALTH} | OpPhase: ${OP_PHASE}"
            [ -n "$SYNC_ERROR" ] && echo "       Error: ${SYNC_ERROR}"
            [ -n "$CONDITION" ] && echo "       Condition: ${CONDITION}"
            
            # Show unhealthy resources on every 5th iteration
            if [ $((i % 5)) -eq 0 ]; then
              echo "       Unhealthy Resources:"
              kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | \
                jq -r '.status.resources[]? | select(.health.status != "Healthy" and .health.status != null) | "         ⚠️ \(.kind)/\(.name): \(.health.status)"' 2>/dev/null || true
            fi
            
            if [ "$SYNC" = "Synced" ] && [ "$HEALTH" = "Healthy" ]; then
              echo ""
              echo "╔══════════════════════════════════════════════════════════════════════════════╗"
              echo "║                     ✅ DEPLOYMENT VERIFICATION PASSED                        ║"
              echo "╚══════════════════════════════════════════════════════════════════════════════╝"
              echo ""
              echo "| Sync Status | ✅ ${SYNC} |" >> $GITHUB_STEP_SUMMARY
              echo "| Health Status | 🟢 ${HEALTH} |" >> $GITHUB_STEP_SUMMARY
              echo "healthy=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            sleep 10
          done
          
          # ═══════════════════════════════════════════════════════════════════════════════
          # SECTION G: FINAL ERROR DUMP (if failed)
          # ═══════════════════════════════════════════════════════════════════════════════
          echo ""
          echo "╔══════════════════════════════════════════════════════════════════════════════╗"
          echo "║                     ❌ DEPLOYMENT VERIFICATION FAILED                        ║"
          echo "╚══════════════════════════════════════════════════════════════════════════════╝"
          
          echo ""
          echo "[G.1] Final Application State:"
          echo "═══════════════════════════════════════════════════════════════════════════════"
          kubectl get application "${APP_NAME}" -n argocd -o json 2>/dev/null | jq '{
            syncStatus: .status.sync.status,
            healthStatus: .status.health.status,
            operationPhase: .status.operationState.phase,
            operationMessage: .status.operationState.message,
            syncResultResources: [.status.operationState.syncResult.resources[]? | {kind, name, status, message}],
            conditions: .status.conditions,
            unhealthyResources: [.status.resources[]? | select(.health.status != "Healthy") | {kind, name, health: .health}]
          }' || echo "Failed to get final state"
          echo "═══════════════════════════════════════════════════════════════════════════════"
          
          # Switch to spoke cluster for final pod check
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          
          echo ""
          echo "[G.2] Final Pod States:"
          echo "────────────────────────────────────────────────"
          kubectl get pods -n "${NAMESPACE}" -o wide 2>&1 || echo "  No pods"
          echo ""
          
          echo "[G.3] Pods Not Ready:"
          echo "────────────────────────────────────────────────"
          kubectl get pods -n "${NAMESPACE}" -o json 2>/dev/null | \
            jq -r '.items[]? | select(.status.phase != "Running") | "  \(.metadata.name): \(.status.phase) - \(.status.conditions[]? | select(.status != "True") | .type + ": " + .message)"' || echo "  None"
          echo ""
          
          echo "[G.4] Recent Events with Errors:"
          echo "────────────────────────────────────────────────"
          kubectl get events -n "${NAMESPACE}" --field-selector type=Warning --sort-by='.lastTimestamp' 2>&1 | tail -10 || echo "  No warning events"
          echo ""
          
          echo "| Sync Status | ⚠️ ${SYNC} |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Status | ⚠️ ${HEALTH} |" >> $GITHUB_STEP_SUMMARY
          [ -n "$SYNC_ERROR" ] && echo "| Error | ${SYNC_ERROR} |" >> $GITHUB_STEP_SUMMARY
          [ -n "$CONDITION" ] && echo "| Condition | ${CONDITION} |" >> $GITHUB_STEP_SUMMARY
          echo "healthy=false" >> $GITHUB_OUTPUT

  # ════════════════════════════════════════════════════════════════════════════════
  # SMOKE TESTS
  # ════════════════════════════════════════════════════════════════════════════════
  smoke-tests:
    name: "🧪 Smoke Tests"
    runs-on: ubuntu-latest
    needs: [verify-deployment]
    outputs:
      passed: ${{ steps.test.outputs.passed }}
    
    steps:
      - name: Run Smoke Tests
        id: test
        run: |
          echo "### 🧪 Smoke Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Endpoint | Status | Response |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|----------|" >> $GITHUB_STEP_SUMMARY
          
          PASSED=true
          
          # Test Vote App
          VOTE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.DEV_URL }}" --connect-timeout 10 -k || echo "000")
          if [ "$VOTE_STATUS" = "200" ] || [ "$VOTE_STATUS" = "301" ] || [ "$VOTE_STATUS" = "302" ]; then
            echo "| Vote App | ✅ | HTTP ${VOTE_STATUS} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Vote App | ⚠️ | HTTP ${VOTE_STATUS} |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Test Results App
          RESULT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.DEV_RESULTS_URL }}" --connect-timeout 10 -k || echo "000")
          if [ "$RESULT_STATUS" = "200" ] || [ "$RESULT_STATUS" = "301" ] || [ "$RESULT_STATUS" = "302" ]; then
            echo "| Results App | ✅ | HTTP ${RESULT_STATUS} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Results App | ⚠️ | HTTP ${RESULT_STATUS} |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "passed=${PASSED}" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**DEV URLs:**" >> $GITHUB_STEP_SUMMARY
          echo "- Vote: ${{ env.DEV_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- Results: ${{ env.DEV_RESULTS_URL }}" >> $GITHUB_STEP_SUMMARY

  # ════════════════════════════════════════════════════════════════════════════════
  # DEPLOYMENT SUMMARY
  # ════════════════════════════════════════════════════════════════════════════════
  deployment-summary:
    name: "📊 Deployment Summary"
    runs-on: ubuntu-latest
    needs: [pre-deploy-check, update-manifests, argocd-sync, verify-deployment, smoke-tests]
    if: always()
    
    steps:
      - name: Generate Summary
        run: |
          echo "## 🚀 DEV Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          
          [ "${{ needs.pre-deploy-check.result }}" = "success" ] && echo "| Pre-Deploy Check | ✅ |" >> $GITHUB_STEP_SUMMARY || echo "| Pre-Deploy Check | ❌ |" >> $GITHUB_STEP_SUMMARY
          [ "${{ needs.update-manifests.result }}" = "success" ] && echo "| Update Manifests | ✅ |" >> $GITHUB_STEP_SUMMARY || echo "| Update Manifests | ❌ |" >> $GITHUB_STEP_SUMMARY
          [ "${{ needs.argocd-sync.result }}" = "success" ] && echo "| ArgoCD Sync | ✅ |" >> $GITHUB_STEP_SUMMARY || echo "| ArgoCD Sync | ❌ |" >> $GITHUB_STEP_SUMMARY
          [ "${{ needs.verify-deployment.result }}" = "success" ] && echo "| Verify Deployment | ✅ |" >> $GITHUB_STEP_SUMMARY || echo "| Verify Deployment | ⚠️ |" >> $GITHUB_STEP_SUMMARY
          [ "${{ needs.smoke-tests.result }}" = "success" ] && echo "| Smoke Tests | ✅ |" >> $GITHUB_STEP_SUMMARY || echo "| Smoke Tests | ⚠️ |" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** \`${{ inputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY

      - name: Notify Slack - DEV Complete
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -z "$SLACK_WEBHOOK" ]; then exit 0; fi
          
          STATUS="${{ needs.smoke-tests.result }}"
          [ "$STATUS" = "success" ] && EMOJI="✅" && COLOR="good" || EMOJI="⚠️" && COLOR="warning"
          
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "attachments": [{
                "color": "'"${COLOR}"'",
                "blocks": [
                  {"type": "header", "text": {"type": "plain_text", "text": "'"${EMOJI}"' DEV Deployment Complete", "emoji": true}},
                  {"type": "section", "fields": [
                    {"type": "mrkdwn", "text": "*Image Tag:*\n`'"${{ inputs.image_tag }}"'`"},
                    {"type": "mrkdwn", "text": "*Environment:*\nDEV"}
                  ]},
                  {"type": "section", "text": {"type": "mrkdwn", "text": "*URLs:*\n• <'"${{ env.DEV_URL }}"'|Vote App>\n• <'"${{ env.DEV_RESULTS_URL }}"'|Results App>"}},
                  {"type": "actions", "elements": [
                    {"type": "button", "text": {"type": "plain_text", "text": "⬆️ Promote to QA"}, "style": "primary", "url": "${{ github.server_url }}/${{ github.repository }}/actions/workflows/40-cd-promote-qa.yaml"}
                  ]}
                ]
              }]
            }' \
            "$SLACK_WEBHOOK" || true
